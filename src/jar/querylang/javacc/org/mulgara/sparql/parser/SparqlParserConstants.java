/* Generated By:JavaCC: Do not edit this line. SparqlParserConstants.java */
package org.mulgara.sparql.parser;

public interface SparqlParserConstants {

  int EOF = 0;
  int COMMENT = 7;
  int SELECT = 8;
  int BASE = 9;
  int ORDER = 10;
  int BY = 11;
  int FROM = 12;
  int GRAPH = 13;
  int STR = 14;
  int IS_URI = 15;
  int PREFIX = 16;
  int CONSTRUCT = 17;
  int LIMIT = 18;
  int NAMED = 19;
  int OPTIONAL = 20;
  int LANG = 21;
  int IS_IRI = 22;
  int DESCRIBE = 23;
  int OFFSET = 24;
  int WHERE = 25;
  int UNION = 26;
  int LANGMATCHES = 27;
  int IS_BLANK = 28;
  int IS_LITERAL = 29;
  int ASK = 30;
  int DISTINCT = 31;
  int FILTER = 32;
  int DATATYPE = 33;
  int REGEX = 34;
  int REDUCED = 35;
  int BOUND = 36;
  int TRUE = 37;
  int SAME_TERM = 38;
  int FALSE = 39;
  int LET = 40;
  int IRI_REF = 70;
  int PNAME_NS = 71;
  int PNAME_LN = 72;
  int BLANK_NODE_LABEL = 73;
  int VAR1 = 74;
  int VAR2 = 75;
  int LANGTAG = 76;
  int MODIFIER = 77;
  int IRI_REF_MOD = 78;
  int PNAME_NS_MOD = 79;
  int PNAME_LN_MOD = 80;
  int Z_9 = 81;
  int Z_9r = 82;
  int Z_9o = 83;
  int INTEGER = 84;
  int DECIMAL = 85;
  int DOUBLE = 86;
  int INTEGER_POSITIVE = 87;
  int DECIMAL_POSITIVE = 88;
  int DOUBLE_POSITIVE = 89;
  int INTEGER_NEGATIVE = 90;
  int DECIMAL_NEGATIVE = 91;
  int DOUBLE_NEGATIVE = 92;
  int EXPONENT = 93;
  int STRING_LITERAL1 = 94;
  int STRING_LITERAL2 = 95;
  int STRING_LITERAL_LONG1 = 96;
  int STRING_LITERAL_LONG2 = 97;
  int ECHAR = 98;
  int NIL = 99;
  int WS = 100;
  int ANON = 101;
  int PN_CHARS_BASE = 102;
  int PN_CHARS_U = 103;
  int VARNAME = 104;
  int PN_CHARS = 105;
  int PN_PREFIX = 106;
  int PN_LOCAL = 107;

  int DEFAULT = 0;
  int IN_COMMENT = 1;

  String[] tokenImage = {
    "<EOF>",
    "\"\\t\"",
    "\"\\n\"",
    "\"\\r\"",
    "\"\\f\"",
    "\" \"",
    "\"#\"",
    "<COMMENT>",
    "\"SELECT\"",
    "\"BASE\"",
    "\"ORDER\"",
    "\"BY\"",
    "\"FROM\"",
    "\"GRAPH\"",
    "\"STR\"",
    "\"isURI\"",
    "\"PREFIX\"",
    "\"construct\"",
    "\"limit\"",
    "\"named\"",
    "\"optional\"",
    "\"lang\"",
    "\"isIRI\"",
    "\"describe\"",
    "\"offset\"",
    "\"where\"",
    "\"union\"",
    "\"LANGMATCHES\"",
    "\"isBLANK\"",
    "\"isLITERAL\"",
    "\"ask\"",
    "\"distinct\"",
    "\"filter\"",
    "\"datatype\"",
    "\"regex\"",
    "\"reduced\"",
    "\"bound\"",
    "\"true\"",
    "\"sameTERM\"",
    "\"false\"",
    "\"let\"",
    "\"*\"",
    "\"ASC\"",
    "\"DESC\"",
    "\"{\"",
    "\".\"",
    "\"}\"",
    "\"(\"",
    "\":=\"",
    "\")\"",
    "\",\"",
    "\";\"",
    "\"a\"",
    "\"a*\"",
    "\"a+\"",
    "\"[\"",
    "\"]\"",
    "\"||\"",
    "\"&&\"",
    "\"=\"",
    "\"!=\"",
    "\"<\"",
    "\">\"",
    "\"<=\"",
    "\">=\"",
    "\"+\"",
    "\"-\"",
    "\"/\"",
    "\"!\"",
    "\"^^\"",
    "<IRI_REF>",
    "<PNAME_NS>",
    "<PNAME_LN>",
    "<BLANK_NODE_LABEL>",
    "<VAR1>",
    "<VAR2>",
    "<LANGTAG>",
    "<MODIFIER>",
    "<IRI_REF_MOD>",
    "<PNAME_NS_MOD>",
    "<PNAME_LN_MOD>",
    "<Z_9>",
    "<Z_9r>",
    "<Z_9o>",
    "<INTEGER>",
    "<DECIMAL>",
    "<DOUBLE>",
    "<INTEGER_POSITIVE>",
    "<DECIMAL_POSITIVE>",
    "<DOUBLE_POSITIVE>",
    "<INTEGER_NEGATIVE>",
    "<DECIMAL_NEGATIVE>",
    "<DOUBLE_NEGATIVE>",
    "<EXPONENT>",
    "<STRING_LITERAL1>",
    "<STRING_LITERAL2>",
    "<STRING_LITERAL_LONG1>",
    "<STRING_LITERAL_LONG2>",
    "<ECHAR>",
    "<NIL>",
    "<WS>",
    "<ANON>",
    "<PN_CHARS_BASE>",
    "<PN_CHARS_U>",
    "<VARNAME>",
    "<PN_CHARS>",
    "<PN_PREFIX>",
    "<PN_LOCAL>",
  };

}
